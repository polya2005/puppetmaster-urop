# How Connectal build system works

## Generating board-specific directories

The top-level project [includes `connectal/Makefile.connectal`](https://github.com/CyanoKobalamyne/pmhw/blob/master/Makefile#L38). So, when you run `make build.awsf1`, it [triggers the generic `build.%` target](https://github.com/cambridgehackers/connectal/blob/master/Makefile.connectal#L56-L57) with `BOARD=awsf1`. This target actually consists of two steps: first, running the dependency `gen.awsf1`, which creates the `awsf1/` folder, and then executing `make all` within that directory (which they named as `PROJECTDIR`).

By the way, other targets like `run.%`, `verilog.%`, `exe.%`, `bits.%` work similarly. They [execute the make targets generated for the board](https://github.com/cambridgehackers/connectal/blob/master/Makefile.connectal#L59-L70).

How did `gen.%` generate a folder for a given board? If you trace the content of `Makefile.connectal`, you'll see that it runs `gentarget`, which executes [`connectal/scripts/makefilegen.py`](https://github.com/cambridgehackers/connectal/blob/master/scripts/makefilegen.py) with a lot of information, including `CONNECTALFLAGS`. The goal of this file is to generate, believe it or not, `Makefile`.

Honestly, `makefilegen.py` is quite dirty. If you dig through the code, you can see that it gets board-specific data from [`connectal/boardinfo/awsf1.json`](https://github.com/cambridgehackers/connectal/blob/master/boardinfo/awsf1.json#L6), including some environmental variables like `CONNECTAL_RUN_SCRIPT` which are put into the generated `Makefile.`

The implicit target `gen.%` also has `prebuild` which seems to pre-generate PCIe core using `fpgamake` for some reason. (If you trace it, you see that it calls its own `connectal_synth_pcie`, which calls `connectal_synth_ip`, which is a wrapper around `fpgamake_ipcore` from a different repository. Why... why...) Overall you can probably ignore this one, though.

Let me re-iterate: `makefilegen.py` generates the `Makefile` inside your board project. `fpgamake` is used for entirely different purpose... for now, so you can ignore it.

## Inside board-specific directory

Okay, let's actually go inside the board folder and see what `all` does. I'm looking inside `awsf1/`, so `awsf1/Makefile`. This is the file that gets run when you call `build.awsf1` or `run.awsf1` or if you manually enter this folder to run `make`. You can see that it has the environmental variables that `makefilegen.py` gathered (like some board-specific `CONNECTAL_RUN_SCRIPT`).

This `Makefile` also includes [`connectal/scripts/Makefile.connectal.build`](https://github.com/cambridgehackers/connectal/blob/master/scripts/Makefile.connectal.build) allowing us to run `make bits` and `make exe`, and eventually `make run`.

## Running the software

Let's start with the simple one: `make run`, assuming you've already built everything else. It calls `RUN_SCRIPT`, which is whatever was defined in `CONNECTAL_RUN_SCRIPT` through the top `Makefile` we ran (which was generated by `makefilegen.py`). For AWS F1, `CONNECTAL_RUN_SCRIPT=$(CONNECTALDIR)/scripts/run.aws`.

The scripts for AWS are defined in [`connectal/awsf1/scripts/aws`](https://github.com/cambridgehackers/connectal/tree/master/scripts/aws). (They're "conveniently" copied to your project's `awsf1/build/scripts`, though. I don't think it ever consistently uses the copied version.) It runs `ubuntu.exe`.

For other boards like `vcu108`, [defined here](https://github.com/cambridgehackers/connectal/blob/master/boardinfo/vcu108.json#L4), it runs [`scripts/run.pcietest`](https://github.com/cambridgehackers/connectal/blob/master/scripts/run.pcietest), which essentially just runs `ubuntu.exe`, just that the wrapper script is called `pcietest` instead of `awsf1`, modulo some other setup stuff. Fun.

## Generating the software

So, we have to see how `ubuntu.exe` got generated through `make exe`.

Well, believe it or not, `makefilegen.py` didn't generate just `Makefile`. It also generates `jni/Ubuntu.mk`, so when you run `make exe` which actually just runs `make ubuntu.exe`, it actually just redirects to this `jni/Ubuntu.mk` file, which has its own `make ubuntu.exe` target, which actually generates a bunch of C++ and wrappers by first getting environmental variables from `scripts/Makefile.connectal.application` to figure out what C++ files to generate. (By the way, it seems to also tries to run `Makefile.autotop` but that never seems to actually be not-empty.) Oh, where are the targets for those C++ files, so, y'know, you can figure out how to generate those files? Well, those targets are in `jni/Makefile.generated_files`, which did not exist, btw. So how the fuck did that file get created? Well... uhh... I grepped it and found it was from `cppgen.py`, which was called by `syntax.py`,  which was created as part of `syntax.timestamp` target, which was called by the `obj/Makefile` target... which, by the way, before running this target will try to include `obj/Makefile` if it has already been created before. Okay... but... I don't recall calling this target. Where was I again? Oh right I was trying to figure out how `jni/Makefile.gnerated_files` got created in the first place. Ahahahaha....

Yea, just don't bother with this.

I mean, to be very fair, this is the meat of the project. They have to take in our BSV interface definitions and use that to generate a bunch of headers and whatnot, which involves going through their own parsing pipeline, etc. so... I guess it must necessarily be complicated...?? Maybe???

Anyhow, if you really just need the software, here's the easiest way:
```
# Make sure main.cpp is removed.
make build.vcu108
cd vcu108
make syntax.timestamp
cd jni
make -f Ubuntu.mk connectal.so
```

## Generating bitstream

To generate bitstream, you run `make bits`, which runs `BITS_DEPENDENCES` targets, which, of course, were defined in your generated `Makefile`.

For AWS F1, it runs the [`build/checkpoints/to_aws/mkTop.SH_CL_routed.dcp` target which was hardcoded in `Makefile.connectal.build`](https://github.com/cambridgehackers/connectal/blob/f182656bfe21160b8b263f3261b041d708adafe8/scripts/Makefile.connectal.build#L421-L422) which runs the [`build.sh` script](https://github.com/cambridgehackers/connectal/blob/master/scripts/aws/build.sh). It's in this script that, at the very end, you can see it executes `$CONNECTALDIR/scripts/aws/create-fpga-image.sh`, `$CONNECTALDIR/scripts/aws/describe-latest-fpga-image.sh`, etc.

From what I can see, the [`create-fpga-image.sh`](https://github.com/cambridgehackers/connectal/blob/master/scripts/aws/create-fpga-image.sh#L27-L29) script uses AWS CLI to upload the build checkpoints to a S3 bucket and `create-fpga-image` on Amazon repository.

 I believe the [`upload.sh` script](https://github.com/cambridgehackers/connectal/blob/master/scripts/aws/upload.sh) is meant for manually re-uploading without having to go through the entire build process, but at this point I prefer to just do it by typing out the commands manually (or writing my own scripts).

For other boards like `vcu108`, `make bits` runs `BITS_DEPENDENCES` which is most likely `hw/mkTop.bit`, except that's not hard-coded in `Makefile.connectal.build` like was for F1. 

Oh right... I meant to talk about how `fpgamake` eventually gets used in the process of generating bitstream. Well, pretend I never promised that.

## Miscellaneous

Btw, did you know that Connectal came with [`scripts/topgen.py`](https://github.com/cambridgehackers/connectal/blob/master/scripts/topgen.py) that we're actually supposed to use for generating top-level `Makefile` and top-level Bluespec? That wasn't documented anywhere, but apparently that's the intention. Or maybe it never got tested, I don't know.


